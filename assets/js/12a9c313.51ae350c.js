"use strict";(self.webpackChunklobaro_docs=self.webpackChunklobaro_docs||[]).push([[1830],{2372:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=a(4848),s=a(8453);const i={sidebar_position:5,displayed_sidebar:"firmwareSidebar",title:"LoRaWAN Communication"},r="LoRaWAN Communication",o={id:"firmware/app-nrf9160-wmbus/lorawan-communication-protocol",title:"LoRaWAN Communication",description:"The Gateway can use LoRaWAN as Uplink technology for forwarding received wMbus telegrams to any network server.",source:"@site/docs/firmware/app-nrf9160-wmbus/lorawan-communication-protocol.md",sourceDirName:"firmware/app-nrf9160-wmbus",slug:"/firmware/app-nrf9160-wmbus/lorawan-communication-protocol",permalink:"/iot/firmware/app-nrf9160-wmbus/lorawan-communication-protocol",draft:!1,unlisted:!1,editUrl:"https://github.com/lobaro/iot/tree/master/docs/firmware/app-nrf9160-wmbus/lorawan-communication-protocol.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,displayed_sidebar:"firmwareSidebar",title:"LoRaWAN Communication"},sidebar:"firmwareSidebar",previous:{title:"Configuration Parameter",permalink:"/iot/firmware/app-nrf9160-wmbus/configuration-parameter"},next:{title:"Cellular IoT Communication",permalink:"/iot/firmware/app-nrf9160-wmbus/cellular-iot-communication-protocol"}},l={},d=[{value:"Uplink Payload Formats",id:"uplink-payload-formats",level:2},{value:"Status Packet (Port 1)",id:"status-packet-port-1",level:3},{value:"Data Packet (PayloadFormat 0)",id:"data-packet-payloadformat-0",level:3},{value:"Examples",id:"examples",level:4},{value:"Length 48 Byte wMBUS telegram",id:"length-48-byte-wmbus-telegram",level:5},{value:"Length 75 byte wMBUS telegram",id:"length-75-byte-wmbus-telegram",level:5},{value:"Length 101 byte wMBUS telegram",id:"length-101-byte-wmbus-telegram",level:5},{value:"Data Packet (PayloadFormat 1)",id:"data-packet-payloadformat-1",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"lorawan-communication",children:"LoRaWAN Communication"}),"\n",(0,n.jsx)(t.p,{children:"The Gateway can use LoRaWAN as Uplink technology for forwarding received wMbus telegrams to any network server."}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["It is ",(0,n.jsx)(t.strong,{children:"not"})," a LoRaWAN Gateway, thus other LoRaWAN Devices can not be received."]})}),"\n",(0,n.jsx)(t.h2,{id:"uplink-payload-formats",children:"Uplink Payload Formats"}),"\n",(0,n.jsx)(t.p,{children:"After collecting wireless M-Bus telegrams over the air, the Bridge starts uploading data via LoRaWAN. There exist two\ndata formats that are transmitted over different LoRaWAN ports. As LoRaWAN can only transmit very short messages, the\nmessage formats contain only data bytes. The meaning of a byte is determined by its position within a message. The\nfollowing describes the package formats used by the wireless M-Bus Bridge."}),"\n",(0,n.jsxs)(t.p,{children:["M-Bus telegrams can be longer as the maximal size of a LoRaWAN-Message. For this cases, the firmware needs to split a\ntelegram into multiple pieces and upload it using multiple LoRaWAN-Messages. There are two different methods this is\ndone, according to the payload pormat you set in the ",(0,n.jsx)(t.a,{href:"/iot/firmware/app-nrf9160-wmbus/configuration-parameter#lorawanparams",children:"firmware configuration"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["A configuration with ",(0,n.jsx)(t.code,{children:"PayloadFormat = 0"})," is focused on easy reassembly of the pieces. The parts are encoded by port\nnumbers and the data can\njust be concatenated together. Payload Formats 1 and 2 add additional information to the telegram. They focus on putting\nas much of a telegram in a single LoRaWAN-Message as possible with respecting the current Spreading Factor."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"LoRaWAN Port"}),(0,n.jsxs)(t.th,{children:[(0,n.jsx)(t.code,{children:"PayloadFormat"})," Configuration"]}),(0,n.jsx)(t.th,{children:"Uplink Message"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"1"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"any"})}),(0,n.jsx)(t.td,{children:"Status Message"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"11-99"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"0"})}),(0,n.jsx)(t.td,{children:"Default PayloadFormat. Part of split telegrams is encoded in Port (e.g. Port 24 = Telegram 2 of 4)."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"101"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"1"})}),(0,n.jsx)(t.td,{children:"Data Message with timestamp and without RSSI. Part of split telegrams is encoded in payload."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"102"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"2"})}),(0,n.jsx)(t.td,{children:"Data Message with timestamp and with RSSI. Part of split telegrams is encoded in payload."})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"status-packet-port-1",children:"Status Packet (Port 1)"}),"\n",(0,n.jsxs)(t.p,{children:["In order to provide some information about the health & connectivity state of the device itself, the device\nsends a status update at a daily basis. The status packet is sent on the first upload phase after activation of the\ndevice (after reboot) and then repeatedly in every upload phase that takes place a day or longer after the previous\nstatus packet. It has a length of 7 or 8 bytes. The battery voltages and ambient temperature are encodes as 16 bit\ninteger using ",(0,n.jsx)(t.strong,{children:"little endian encoding"}),"."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Field"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"Bytes"}),(0,n.jsx)(t.th,{children:"Description"}),(0,n.jsx)(t.th,{children:"Example"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"version"}),(0,n.jsx)(t.td,{children:"uint8[3]"}),(0,n.jsx)(t.td,{children:"0-2"}),(0,n.jsx)(t.td,{children:"Firmware Version"}),(0,n.jsx)(t.td,{children:"1, 5, 1 \u2261 v1.5.1"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"v_bat"}),(0,n.jsx)(t.td,{children:"uint16"}),(0,n.jsx)(t.td,{children:"3-4"}),(0,n.jsx)(t.td,{children:"Battery Voltage [mV]"}),(0,n.jsx)(t.td,{children:"2947 \u2261 2.947V"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"temp"}),(0,n.jsx)(t.td,{children:"int16"}),(0,n.jsx)(t.td,{children:"5-6"}),(0,n.jsx)(t.td,{children:"Temperature [1/10 \xb0C]"}),(0,n.jsx)(t.td,{children:"246  \u2261 24.6\xb0C"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"flag"}),(0,n.jsx)(t.td,{children:"int8"}),(0,n.jsx)(t.td,{children:"7"}),(0,n.jsx)(t.td,{children:"Internal Flag"}),(0,n.jsx)(t.td,{children:"0x01"})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"data-packet-payloadformat-0",children:"Data Packet (PayloadFormat 0)"}),"\n",(0,n.jsx)(t.p,{children:"After each wMBUS collecting phase, all saved telegrams will be uploaded via LoRaWAN uplink\nmessages as fast as possible. The received wMBUS telegrams that did pass the configured filters will be\nuploaded without any modification in one or more LoRaWAN messages."}),"\n",(0,n.jsx)(t.p,{children:"If a wMBUS telegram is bigger than the bridge\nconfiguration parameter loraMaxMsgSize the transmission will be done using multiple LoRaWAN messages. This parameter is\nlimited to \u2264 50 bytes due to LoRaWANs maximum payload size restrictions. In case of telegram splitting is needed the\nreceiving backend application server as to reassemble the original wMBUS telegram before decryption & parsing of the\nmeter data. This is done by simply joining the messages together in the order of receive. The LoRaWAN port encodes\nidentifies a LoRaWAN fragment of the original wireless M-Bus telegram. This way partial messages can be identified using\nthe LoRaWAN Port:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"10 < LoRaWAN Port < 100 \u2261 (Part Number | Total Parts)"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Gaps in the LoRaWAN Frame Counter are giving a hint for missing telegram parts which can happen in LoRaWAN since it's a\nALOHA based protocol, e.g. collisions and some packet losses are accepted by principle of operation. In case the backend\nnoticed a missing packet the wMBUS telegram can't be assembled anymore as described before."}),"\n",(0,n.jsx)(t.h4,{id:"examples",children:"Examples"}),"\n",(0,n.jsxs)(t.p,{children:["With a configuration of ",(0,n.jsx)(t.code,{children:"loraMaxMsgSize"})," = 50:"]}),"\n",(0,n.jsx)(t.h5,{id:"length-48-byte-wmbus-telegram",children:"Length 48 Byte wMBUS telegram"}),"\n",(0,n.jsx)(t.p,{children:"Will be send on LoRaWAN port 11. Port 11 says it is the first message of only one message (no splitting)."}),"\n",(0,n.jsx)(t.h5,{id:"length-75-byte-wmbus-telegram",children:"Length 75 byte wMBUS telegram"}),"\n",(0,n.jsx)(t.p,{children:"Will be send in two messages on LoRaWAN ports 12 and 22. Port 12 means this part one of a wMBUS telegram that got\nsplitted into two LoRaWAN messages. Port 22 means that this data is the 2nd part of the original wMBUS data. Both parts\nhave to been concatenated in the order of receive by the backend."}),"\n",(0,n.jsx)(t.h5,{id:"length-101-byte-wmbus-telegram",children:"Length 101 byte wMBUS telegram"}),"\n",(0,n.jsx)(t.p,{children:"Will be send in three messages on LoRaWAN ports 13, 23 and 33. Port 13 means this part one of a wMBUS telegram that got\nsplitted into three LoRaWAN messages. Port 23 means that this data is the 2nd part of the original wMBUS data. Port 33\nmeans that this data is the 3rd part of the original wMBUS data. All three parts have to been concatenated in the order\nof receive by the backend."}),"\n",(0,n.jsx)(t.h3,{id:"data-packet-payloadformat-1",children:"Data Packet (PayloadFormat 1)"}),"\n",(0,n.jsx)(t.p,{children:"When using Payload Format 1, collected telegrams are uploaded on a single Port: 101. For each telegram there will be\nadded the timestamp of reception. The first byte of messages on Port 101 encodes splitting of messages as follows."}),"\n",(0,n.jsxs)(t.p,{children:["Every Uplink on Port 101 is prefixed with a single byte, where the least significant Bit indicates if that Uplink is the\nfirst part of a message, and the second least significant Bit indicates if that Uplink is the last part or a message. So\nthere are 4 different possible values for the ",(0,n.jsx)(t.strong,{children:"first Byte"})," of an Uplink on Port 101:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["0x03:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"This Uplink is both first and final part of a message. So the remaining Bytes in this Uplink contain the whole\nmessage."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["0x02:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"This Uplink is the last but not the first part of a message. There has been at least one Uplink before this one,\nthat contained data that needs to be prepended to the current Uplink in order to get the full Message"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["0x01:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"This Uplink is the first but not the last part of a message. There follows at least one Uplink that contains more\ndata to be appended to the current's data in order to get the full message."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["0x00:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"This Uplink is neither first nor last part of a message. There has been at least one Uplink before this one that\ncontains more data of the current Message, and there follows at least one more Uplink with data for this Message."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"So each message sent on Port 101, whether it is contained in a single Uplink or spread over multiple ones, starts with\nan Uplink where the least significant Bit of the first Byte is set. Each Message ends with an Uplink where the second\nleast significant Bit of the first Byte is set. In cases where the Message fits in a single Uplink, that Uplink is both\nfirst and last Uplink, and therefore both Bits are set."}),"\n",(0,n.jsx)(t.p,{children:"The combination of those two Bits and the Frame Counter of the Uplinks makes it possible to upload Messages of any\nlength while allowing the receiving side to now exactly, if a Message has been transferred completely, or if part of it\nis missing (when there are Frame Counter values missing)."}),"\n",(0,n.jsx)(t.p,{children:"The Bridge puts as many Bytes in each Uplink as possible for the current Spreading Factor, even if the Spreading Factor\nchanges between Uplinks because of ADR."}),"\n",(0,n.jsx)(t.p,{children:"When the data of all Uplinks that are part of a single Message are appended in order of reception (after removing the\nfirst Byte of each Uplink), you get the payload Data of a full message."})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>o});var n=a(6540);const s={},i=n.createContext(s);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);